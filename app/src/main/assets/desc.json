{
  "binary_search": {
    "Binary Search": "Binary Search is a search algorithm that finds the position of a target value within a sorted array. It works by comparing the target value to the middle element of the array; if they are unequal, the lower or upper half of the array is eliminated depending on the result and the search is repeated in the remaining subarray until it is successful.",
    "Applications": [
      "Finding values in a sorted collection",
      "Traversing binary search trees"
    ],
    "Complexity": {
      "Time": "worst O(log(N)), best O(1), average O(log(N))",
      "Space": "worst O(log(N)) - recursive, O(1) - iterative"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Binary_search_algorithm'>Wikipedia</a>"
    ]
  },
  "bst_search": {
    "Binary Search Tree": "Binary search trees (BST), sometimes called ordered or sorted binary trees, are a particular type of containers: data structures that store \"items\" (such as numbers, names etc.) in memory. They allow fast lookup, addition and removal of items, and can be used to implement either dynamic sets of items, or lookup tables that allow finding an item by its key (e.g., finding the phone number of a person by name).",
    "Applications": [
      "Search applications where data is constantly entering/leaving such as map and set objects in many languages' library."
    ],
    "Complexity": {
      "Time": " Best : O(1) Average : O(logN) Worst : O(N) ",
      "Space": "O(n)"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Binary_search_tree'>Wikipedia</a>"
    ]
  },
  "bst_insert": {
    "Binary Search Tree": "Binary search trees (BST), sometimes called ordered or sorted binary trees, are a particular type of containers: data structures that store \"items\" (such as numbers, names etc.) in memory. They allow fast lookup, addition and removal of items, and can be used to implement either dynamic sets of items, or lookup tables that allow finding an item by its key (e.g., finding the phone number of a person by name).",
    "Applications": [
      "Search applications where data is constantly entering/leaving such as map and set objects in many languages' library."
    ],
    "Complexity": {
      "Time": " Best : O(1) Average : O(logN) Worst : O(N) ",
      "Space": "O(n)"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Binary_search_tree'>Wikipedia</a>"
    ]
  },
  "bubble_sort": {
    "Bubble Sort": "Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.",
    "Complexity": {
      "Time": "worst O(n^2), best O(n), average O(n^2)",
      "Space": "worst O(1) auxiliary"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Bubble_sort'>Wikipedia</a>"
    ]
  },
  "insertion_sort": {
    "Insertion Sort": "Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.",
    "Complexity": {
      "Time": "worst O(n^2), best O(n), average O(n^2)",
      "Space": "worst O(1) auxiliary"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Insertion_sort'>Wikipedia</a>"
    ]
  },
  "linked_list": {
    "Singly linked list": "A Linked List is a linear collection of data elements, called nodes, each pointing to the next node by means of a pointer. It is a data structure consisting of a group of nodes which together represent a sequence. Under the simplest form, each node is composed of data and a reference (in other words, a link) to the next node in the sequence. ",
    "Complexity": {
      "Time": "<br>Search: worst O(n), average O(n)<br>   Access: worst O(n), average O(n) <br>   Deletion: worst O(1), average O(1) <br>  Insertion : worst O(1), average O(1) <br> ",
      "Space": "<br>worst O(n)"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Linked_list'>Wikipedia</a>"
    ]
  },
  "stack": {
    "Stack": "A stack is an abstract data type that serves as a collection of elements, with two principal operations: push, which adds an element to the collection, and pop, which removes the most recently added element that was not yet removed. The order in which elements come off a stack gives rise to its alternative name, LIFO (for last in, first out). Additionally, a peek operation may give access to the top without modifying the stack.",
    "Complexity": {
      "Time": "<br>Search: worst O(n), average O(n)<br>   Access: worst O(n), average O(n) <br>   Deletion: worst O(1), average O(1) <br>  Insertion : worst O(1), average O(1) <br> ",
      "Space": "<br>worst O(n)"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Stack_(abstract_data_type)'>Wikipedia</a>"
    ]
  },
  "bfs": {
    "BFS": "Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors.",
    "Applications": [
      "Copying garbage collection, Cheney's algorithm",
      "Finding the shortest path between two nodes u and v, with path length measured by number of edges (an advantage over depth-first search)",
      "Testing a graph for bipartiteness",
      "(Reverse) Cuthill–McKee mesh numbering",
      "Ford–Fulkerson method for computing the maximum flow in a flow network",
      "Serialization/Deserialization of a binary tree vs serialization in sorted order, allows the tree to be re-constructed in an efficient manner.",
      "Construction of the failure function of the Aho-Corasick pattern matcher."
    ],
    "Complexity": {
      "Time": "worst O(|E|)",
      "Space": "worst O(|V|)"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Breadth-first_search'>Wikipedia</a>"
    ]
  },
  "dfs": {
    "DFS": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.",
    "Applications": [
      "Finding connected components.",
      "Topological sorting.",
      "Finding 2-(edge or vertex)-connected components.",
      "Finding 3-(edge or vertex)-connected components.",
      "Finding the bridges of a graph.",
      "Generating words in order to plot the Limit Set of a Group.",
      "Finding strongly connected components.",
      "Planarity testing",
      "Solving puzzles with only one solution, such as mazes. (DFS can be adapted to find all solutions to a maze by only including nodes on the current path in the visited set.)",
      "Maze generation may use a randomized depth-first search.",
      "Finding biconnectivity in graphs."
    ],
    "Complexity": {
      "Time": "worst O(|E|)",
      "Space": "worst O(|V|)"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Depth-first_search'>Wikipedia</a>"
    ]
  },
  "dijkstra": {
    "Dijkstra": "Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.",
    "Complexity": {
      "time": "worst O(|V|^2)",
      "space": "worst O(|V|)"
    },
    "References": [
      "<a href='https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm'>Wikipedia</a>"
    ]
  }
}